<!DOCTYPE HTML>
<html lang="zh" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cairo编程语言 Starknet示例</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">介绍</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">入门</li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Starknet 合约的基础知识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1.1.html"><strong aria-hidden="true">1.1.</strong> 变量</a></li><li class="chapter-item expanded "><a href="chapter_1.2.html"><strong aria-hidden="true">1.2.</strong> 构造函数</a></li><li class="chapter-item expanded "><a href="chapter_1.3.html"><strong aria-hidden="true">1.3.</strong> 可见性和可变性</a></li><li class="chapter-item expanded "><a href="chapter_1.4.html"><strong aria-hidden="true">1.4.</strong> 柜台合约示例</a></li><li class="chapter-item expanded "><a href="chapter_1.5.html"><strong aria-hidden="true">1.5.</strong> 映射</a></li><li class="chapter-item expanded "><a href="chapter_1.6.html"><strong aria-hidden="true">1.6.</strong> 错误</a></li><li class="chapter-item expanded "><a href="chapter_1.7.html"><strong aria-hidden="true">1.7.</strong> 活动</a></li><li class="chapter-item expanded "><a href="chapter_1.8.html"><strong aria-hidden="true">1.8.</strong> 存储自定义类型</a></li><li class="chapter-item expanded "><a href="chapter_1.9.html"><strong aria-hidden="true">1.9.</strong> 入口点中的自定义类型</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> 合约部署并与之交互</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2.1.html"><strong aria-hidden="true">2.1.</strong> 工厂模式</a></li><li class="chapter-item expanded "><a href="chapter_2.2.html"><strong aria-hidden="true">2.2.</strong> 合约接口和Traits生成</a></li><li class="chapter-item expanded "><a href="chapter_2.3.html"><strong aria-hidden="true">2.3.</strong> 调用其他合约</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> 测试合约</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">4.</strong> Cairo备忘单</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4.1.html"><strong aria-hidden="true">4.1.</strong> Felt</a></li><li class="chapter-item expanded "><a href="chapter_4.2.html"><strong aria-hidden="true">4.2.</strong> Mapping</a></li><li class="chapter-item expanded "><a href="chapter_4.3.html"><strong aria-hidden="true">4.3.</strong> 数组</a></li><li class="chapter-item expanded "><a href="chapter_4.4.html"><strong aria-hidden="true">4.4.</strong> 循环</a></li><li class="chapter-item expanded "><a href="chapter_4.5.html"><strong aria-hidden="true">4.5.</strong> Match</a></li><li class="chapter-item expanded "><a href="chapter_4.6.html"><strong aria-hidden="true">4.6.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="chapter_4.7.html"><strong aria-hidden="true">4.7.</strong> 类型转换</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">应用实例</li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">5.</strong> 可升级合约</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">6.</strong> Defi金库</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">7.</strong> ERC20代币</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">8.</strong> 恒定乘积 AMM</a></li><li class="chapter-item expanded affix "><li class="part-title">先进理念</li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">9.</strong> 写入任意村粗槽</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">10.</strong> 存储数组</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">11.</strong> 结构体作为映射键</a></li><li class="chapter-item expanded "><a href="chapter_12.html"><strong aria-hidden="true">12.</strong> 优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_12.1.html"><strong aria-hidden="true">12.1.</strong> 存储优化</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Cairo编程语言 Starknet示例</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="starknet-实例"><a class="header" href="#starknet-实例">Starknet 实例</a></h1>
<p><strong>Starknet By Examples</strong> 是一个示例集，演示了如何使用 Cairo 编程语言在 Starknet 上创建智能合约。</p>
<p><strong>Starknet</strong> 是一个无需许可的 Validity-Rollup，支持通用计算。它目前被用作以太坊第 2 层。Starknet 使用 STARK 密码证明系统来确保高安全性和可扩展性。</p>
<p>Starknet 智能合约是用 <strong>Cairo</strong> 编写的。Cairo 是一种图灵完备的编程语言，旨在编写可证明的程序，将 zk-STARK 证明系统从程序员手中抽象出来。</p>
<p>本书当前版本使用 <strong>scarb 2.3.0</strong>。</p>
<h2 id="谁适合学习"><a class="header" href="#谁适合学习">谁适合学习？</a></h2>
<p><strong>Starknet By Example</strong> 针对那些希望快速学习如何使用 Cairo 在 Starknet 上编写智能合约，同时具有编程和区块链技术背景的人。</p>
<p>第一章将使您基本了解 Cairo 编程语言，以及如何在 Starknet 上编写、部署和使用智能合约。后续章节将涵盖更高级的主题，并向您展示如何编写更复杂的智能合约。</p>
<h2 id="进一步阅读"><a class="header" href="#进一步阅读">进一步阅读</a></h2>
<p>如果您想了解更多关于 Cairo 编程语言的知识，可以阅读<a href="https://cairo-book.github.io/">Cairo Book</a>。如果您对 Starknet 感兴趣，可以查阅<a href="https://docs.starknet.io/">Starknet 文档</a>和<a href="https://book.starknet.io/">Starknet Book</a>。</p>
<p>以下是其他可能对您有用的资源列表：</p>
<ul>
<li><a href="https://github.com/shramee/starklings-cairo1">Starklings</a>：一个交互式教程，帮助您启动并运行 Cairo v1 和 Starknet</li>
<li><a href="https://cairopractice.com/">Cairopractice</a>：包含一系列有关 Cairo 和 Starknet 的文章的博客</li>
<li><a href="https://cairo-by-example.com/">Cairo示例</a>：通过简单示例介绍 Cairo</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo智能合约基础知识"><a class="header" href="#cairo智能合约基础知识">Cairo智能合约基础知识</a></h1>
<p>以下章节将向您介绍 Starknet 智能合约以及如何在开罗编写它们。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="变量"><a class="header" href="#变量">变量</a></h1>
<p>Cairo 合约中有 3 种类型的变量：</p>
<ul>
<li>Local
<ul>
<li>在函数内部声明</li>
<li>不存储在区块链上</li>
</ul>
</li>
<li>Storage
<ul>
<li><code>Storage</code>在合约结构中声明</li>
<li>可以从一个执行访问另一个执行</li>
</ul>
</li>
<li>Global
<ul>
<li>提供有关区块链的信息</li>
<li>可以在任何地方访问，甚至在库函数中</li>
</ul>
</li>
</ul>
<h2 id="局部变量"><a class="header" href="#局部变量">局部变量</a></h2>
<p>局部变量在特定函数或代码块的范围内使用和访问。它们是临时的，仅在特定函数或块执行期间存在。</p>
<p>局部变量存储在内存中，不存储在区块链上。这意味着无法从一个执行到另一个执行访问它们。局部变量可用于存储仅在特定上下文中相关的临时数据。它们还通过为中间值命名来使代码更具可读性。</p>
<p>以下是一个仅包含局部变量的合约的简单示例：</p>
<h2 id="局部变量示例"><a class="header" href="#局部变量示例">局部变量示例</a></h2>
<p>在这个示例中，我们展示了一个使用 StarkNet 编写的合约，包含局部变量的使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod LocalVariablesExample {
    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl LocalVariablesExample of ILocalVariablesExample {
        #[external(v0)]
        fn do_something(self: @ContractState, value: u32) -&gt; u32 {
            // 这个变量仅在当前块中可用。一旦超出作用域，就无法访问它。
            let increment = 10;

            {
                // 代码块的作用域允许声明局部变量
                // 我们可以访问在更高作用域中定义的变量。
                let sum = value + increment;
                sum
            }
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x015B3a10F9689BeD741Ca3C210017BC097122CeF76f3cAA191A20ff8b9b56b96">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/variables/src/local_variables.cairo">Remix</a>中使用它。</p>
<h2 id="存储变量"><a class="header" href="#存储变量">存储变量</a></h2>
<p>存储变量是合约中的持久数据，存储在区块链上。它们可以从一个执行到另一个执行访问，使合约能够随着时间的推移保留和更新信息。</p>
<p>要写入或更新存储变量，您需要通过发送交易与合约的外部入口点进行交互。</p>
<p>与之相反，您可以免费读取状态变量，无需任何事务，只需与节点进行交互即可。</p>
<p>以下是一个简单的示例合约，其中包含一个存储变量：</p>
<h2 id="存储变量示例"><a class="header" href="#存储变量示例">存储变量示例</a></h2>
<p>在这个示例中，我们展示了一个使用 StarkNet 编写的合约，包含存储变量的使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod StorageVariablesExample {
    // 所有存储变量都包含在一个名为 Storage 的结构体中，并带有 `#[storage]` 属性
    #[storage]
    struct Storage {
        // 存储一个数字的存储变量
        value: u32
    }

    #[abi(per_item)]
    #[generate_trait]
    impl StorageVariablesExample of IStorageVariableExample {
        // 通过发送调用外部函数的交易来写入存储变量
        #[external(v0)]
        fn set(ref self: ContractState, value: u32) {
            self.value.write(value);
        }

        // 无需发送交易即可读取存储变量
        #[external(v0)]
        fn get(ref self: ContractState) -&gt; u32 {
            self.value.read()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x06eA827B32875483709b785A7F9e846a52776Cd8D42C3fE696218c2624b0DCCa">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/variables/src/local_variables.cairo">Remix</a>中使用它。</p>
<h2 id="全局变量"><a class="header" href="#全局变量">全局变量</a></h2>
<p>全局变量是预定义的变量，提供有关区块链和当前执行环境的信息。它们可以随时随地访问！</p>
<p>在 StarkNet 中，您可以使用 starknet 核心库中包含的特定函数来访问全局变量。</p>
<p>例如，<code>get_caller_address</code> 函数返回当前交易的调用者地址，函数 <code>get_contract_address</code> 返回当前合约的地址。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod GlobalExample {
    // import the required functions from the starknet core library 
    use starknet::get_caller_address;

    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl GlobalExampleImpl of IGlobalExample {
        #[external(v0)]
        fn foo(ref self: ContractState) {
            // Call the get_caller_address function to get the sender address
            let caller = get_caller_address();
            // ...
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x05bD2F3943bd4e030f85678b55b2EC2C1be939e32388530FB20ED967B3Be433F">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/variables/src/global_variables.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构造函数"><a class="header" href="#构造函数">构造函数</a></h1>
<p>构造函数是一种特殊类型的函数，在部署合约时仅运行一次，可用于初始化合约的状态。您的合约不得有多个构造函数，并且该构造函数必须使用 <code>#[constructor]</code> 属性进行注释。另外，一个好的做法是为该函数命名 <code>constructor</code>。</p>
<p>以下是一个简单的示例，演示了如何通过在构造函数内定义逻辑来初始化部署时合约的状态。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod ExampleConstructor {
    use starknet::ContractAddress;

    #[storage]
    struct Storage {
        names: LegacyMap::&lt;ContractAddress, felt252&gt;,
    }

    // The constructor is decorated with a `#[constructor]` attribute.
    // It is not inside an `impl` block.
    #[constructor]
    fn constructor(ref self: ContractState, name: felt252, address: ContractAddress) {
        self.names.write(address, name);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x017fd6558e67451dA583d123D77F4e2651E91502D08F8F8432355293b11e1f8F">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/constructor/src/constructor.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可见性和可变性"><a class="header" href="#可见性和可变性">可见性和可变性</a></h1>
<h2 id="能见度"><a class="header" href="#能见度">能见度</a></h2>
<p>Starknet 合约中有两种类型的函数：</p>
<ul>
<li>可从外部访问并可由任何人调用的函数。</li>
<li>只能在内部访问并且只能由合约中的其他函数调用的函数。</li>
</ul>
<p>这些功能通常也分为两个不同的实现块。外部可访问函数的第一个 <code>impl</code> 块用属性显式注释 <code>#[abi(embed_v0)]</code>。这表明该块内的所有函数都可以作为事务或视图函数调用。内部可访问函数的第二个 <code>impl</code> 块没有任何属性注释，这意味着默认情况下该块内的所有函数都是私有的。</p>
<h2 id="状态可变性"><a class="header" href="#状态可变性">状态可变性</a></h2>
<p>无论函数是内部函数还是外部函数，它都可以修改合约的状态，也可以不修改。当我们声明与智能合约内的存储变量交互的函数时，我们需要通过将其添加为函数的第一个参数来明确声明我们正在访问。这可以通过两种不同的方式完成：</p>
<ul>
<li>如果我们希望我们的函数能够改变合约的状态，我们可以像这样通过引用传递它 <code>ref self: ContractState</code>。</li>
<li>如果我们希望我们的函数是只读的并且不改变合约的状态，我们可以通过快照传递它，如下所示 <code>self: @ContractState</code>。</li>
</ul>
<p>只读函数，也称为视图函数，可以直接调用，无需进行事务。您可以通过 RPC 节点直接与它们交互以读取合约的状态，并且它们可以自由调用！另一方面，修改合约状态的外部函数只能通过进行交易来调用。</p>
<p>内部函数不能从外部调用，但对于状态可变性也适用相同的原则。</p>
<p>让我们看一个简单的合约示例，看看它们的实际效果：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait IExampleContract&lt;TContractState&gt; {
    fn set(ref self: TContractState, value: u32);
    fn get(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
mod ExampleContract {
    #[storage]
    struct Storage {
        value: u32
    }

    // The `abi(embed_v0)` attribute indicates that all the functions in this implementation can be called externally.
    // Omitting this attribute would make all the functions in this implementation internal.
    #[abi(embed_v0)]
    impl ExampleContract of super::IExampleContract&lt;ContractState&gt; {
        // The `set` function can be called externally because it is written inside an implementation marked as `#[external]`.
        // It can modify the contract's state as it is passed as a reference.
        fn set(ref self: ContractState, value: u32) {
            self.value.write(value);
        }

        // The `get` function can be called externally because it is written inside an implementation marked as `#[external]`.
        // However, it can't modify the contract's state is passed as a snapshot: it is only a &quot;view&quot; function.
        fn get(self: @ContractState) -&gt; u32 {
            // We can call an internal function from any functions within the contract
            PrivateFunctionsTrait::_read_value(self)
        }
    }

    // The lack of the `external` attribute indicates that all the functions in this implementation can only be called internally.
    // We name the trait `PrivateFunctionsTrait` to indicate that it is an internal trait allowing us to call internal functions.
    #[generate_trait]
    impl PrivateFunctions of PrivateFunctionsTrait {
        // The `_read_value` function is outside the implementation that is marked as `#[abi(embed_v0)]`, so it's an _internal_ function
        // and can only be called from within the contract.
        // It can modify the contract's state as it is passed as a reference.
        fn _read_value(self: @ContractState) -&gt; u32 {
            self.value.read()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x0071dE3093AB58053b0292C225aa0eED40293e7694A0042685FF6D813d39889F">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/constructor/src/constructor.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单计数器"><a class="header" href="#简单计数器">简单计数器</a></h1>
<p>这是一个简单的反合约。</p>
<p>它的工作原理如下：</p>
<ul>
<li>合约有一个名为“counter”的状态变量，初始化为 0。</li>
<li>当用户调用“increment”时，合约将计数器加 1。</li>
<li>当用户调用“decrement”时，合约会将计数器减 1。</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait ISimpleCounter&lt;TContractState&gt; {
    fn get_current_count(self: @TContractState) -&gt; u128;
    fn increment(ref self: TContractState);
    fn decrement(ref self: TContractState);
}

#[starknet::contract]
mod SimpleCounter {
    #[storage]
    struct Storage {
        // Counter variable
        counter: u128,
    }

    #[constructor]
    fn constructor(ref self: ContractState, init_value: u128) {
        // Store initial value
        self.counter.write(init_value);
    }

    #[abi(embed_v0)]
    impl SimpleCounter of super::ISimpleCounter&lt;ContractState&gt; {
        fn get_current_count(self: @ContractState) -&gt; u128 {
            return self.counter.read();
        }

        fn increment(ref self: ContractState) {
            // Store counter value + 1
            let counter = self.counter.read() + 1;
            self.counter.write(counter);
        }
        fn decrement(ref self: ContractState) {
            // Store counter value - 1
            let counter = self.counter.read() - 1;
            self.counter.write(counter);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x01664a69Fe701a1df7Bb0ae4A353792d0cf4E27146ee860075cbf6108b1D5718">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/counter/src/contracts.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="映射"><a class="header" href="#映射">映射</a></h1>
<p>映射是一种键值数据结构，用于在智能合约中存储数据。在开罗，它们是使用 <code>LegacyMap</code> 类型来实现的。需要注意的是，该 <code>LegacyMap</code> 类型只能在 <code>Storage</code> 合约的结构体内部使用，不能在其他地方使用。</p>
<p>在这里，我们演示如何使用 <code>LegacyMap</code> 在合约中的类型，在 <code>type</code> 的键 <code>ContractAddress</code> 和 <code>type</code> 的值之间进行映射 <code>felt252</code>。键值类型在尖括号 &lt;&gt; 内指定。我们通过调用 <code>write()</code> 方法并传入键和值来写入映射。类似地，我们可以通过调用 <code>read()</code> 方法并传入相关键来读取与给定键关联的值。</p>
<p>一些附加说明：</p>
<ul>
<li>
<p>更复杂的键值映射是可能的，例如我们可以用来 <code>LegacyMap::&lt;(ContractAddress, ContractAddress), felt252&gt;</code> 在 ERC20 代币合约上创建津贴。</p>
</li>
<li>
<p>在映射中， key 处的值的地址 <code>k_1,...,k_n</code> 是 Pedersen 哈希的 <code>h(...h(h(sn_keccak(variable_name),k_1),k_2),...,k_n) 位置 ℎ</code>，并取最终值 <code>mod 2251−256</code>。您可以在 <a href="https://www.starkware.co/docs/starknet/language-specifications/storage-layout">Starknet 文档</a> 中了解有关合约存储布局的更多信息。</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod MapContract {
    use starknet::ContractAddress;

    #[storage]
    struct Storage {
        // The `LegacyMap` type is only available inside the `Storage` struct.
        map: LegacyMap::&lt;ContractAddress, felt252&gt;,
    }

    #[abi(per_item)]
    #[generate_trait]
    impl MapContractImpl of IMapContract {
        #[external(v0)]
        fn set(ref self: ContractState, key: ContractAddress, value: felt252) {
            self.map.write(key, value);
        }

        #[external(v0)]
        fn get(self: @ContractState, key: ContractAddress) -&gt; felt252 {
            self.map.read(key)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x06214AB4c23Cc545bf2221D465eB83aFb7412779AD498BD48a724B3F645E3505">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/counter/src/contracts.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误"><a class="header" href="#错误">错误</a></h1>
<p>错误可用于处理智能合约执行期间可能发生的验证和其他情况。如果在执行智能合约调用期间引发错误，则会停止执行并恢复交易期间所做的任何更改。</p>
<p>要引发错误，请使用 <code>assert</code> 或 <code>panic</code> 函数：</p>
<ul>
<li>
<p><code>assert</code> 用于验证条件。如果检查失败，则会抛出错误以及指定值（通常是消息）。与 Solidity 中的声明类似 <code>require</code>。</p>
</li>
<li>
<p><code>panic</code> 立即停止执行并给出给定的错误值。当要检查的条件很复杂并且存在内部错误时应该使用它。与 Solidity 中的声明类似 <code>revert</code>。（使用 <code>panic_with_felt252</code> 可以直接传入一个 <code>felt252</code> 作为错误值）</p>
</li>
</ul>
<p>下面是一个简单的示例，演示了这些函数的用法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod ErrorsExample {
    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl ErrorsExample of IErrorsExample {
        #[external(v0)]
        fn test_assert(self: @ContractState, i: u256) {
            // Assert used to validate a condition
            // and abort execution if the condition is not met
            assert(i &gt; 0, 'i must be greater than 0');
        }

        #[external(v0)]
        fn test_panic(self: @ContractState, i: u256) {
            if (i == 0) {
                // Panic used to abort execution directly
                panic_with_felt252('i must not be 0');
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x0022664463FF0b711CC9B549a9E87d65A0882bB1D29338C4108696B8F2216a40">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/errors/src/simple_errors.cairo">Remix</a>中使用它。</p>
<h2 id="自定义错误"><a class="header" href="#自定义错误">自定义错误</a></h2>
<p>您可以通过在特定模块中定义错误代码来简化错误处理。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod Errors {
    const NOT_POSITIVE: felt252 = 'must be greater than 0';
    const NOT_NULL: felt252 = 'must not be null';
}

#[starknet::contract]
mod CustomErrorsExample {
    use super::Errors;

    #[storage]
    struct Storage {}

    #[abi(per_item)]
    #[generate_trait]
    impl CustomErrorsExample of ICustomErrorsExample {
        #[external(v0)]
        fn test_assert(self: @ContractState, i: u256) {
            assert(i &gt; 0, Errors::NOT_POSITIVE);
        }

        #[external(v0)]
        fn test_panic(self: @ContractState, i: u256) {
            if (i == 0) {
                panic_with_felt252(Errors::NOT_NULL);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x0501CD5da5B453a18515B5A20b8029bd7583DFE7a399ad9f79c284F7829e4A57">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/errors/src/custom_errors.cairo">Remix</a>中使用它。</p>
<h2 id="保险库示例"><a class="header" href="#保险库示例">保险库示例</a></h2>
<p>这是另一个示例，演示了在更复杂的合约中如何使用错误：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod VaultErrors {
    const INSUFFICIENT_BALANCE: felt252 = 'insufficient_balance';
    // you can define more errors here
}

#[starknet::contract]
mod VaultErrorsExample {
    use super::VaultErrors;

    #[storage]
    struct Storage {
        balance: u256,
    }

    #[abi(per_item)]
    #[generate_trait]
    impl VaultErrorsExample of IVaultErrorsExample {
        #[external(v0)]
        fn deposit(ref self: ContractState, amount: u256) {
            let mut balance = self.balance.read();
            balance = balance + amount;
            self.balance.write(balance);
        }

        #[external(v0)]
        fn withdraw(ref self: ContractState, amount: u256) {
            let mut balance = self.balance.read();

            assert(balance &gt;= amount, VaultErrors::INSUFFICIENT_BALANCE);

            // Or using panic:
            if (balance &gt;= amount) {
                panic_with_felt252(VaultErrors::INSUFFICIENT_BALANCE);
            }

            let balance = balance - amount;

            self.balance.write(balance);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x020C2da26F42A28Ef54ED428eF1810FE433784b055f9bF315C5d992b1579C268">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/errors/src/custom_errors.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="活动"><a class="header" href="#活动">活动</a></h1>
<p>事件是从合约发出数据的一种方式。所有事件都必须在枚举中定义 <code>Event</code>，并且必须使用 <code>#[event]</code> 属性进行注释。事件被定义为派生 <code>#[starknet::Event]</code> 特征的结构。该结构的字段对应于将发出的数据。可以对事件建立索引，以便稍后查询数据时轻松快速地访问。<code>#[key]</code> 可以通过向字段成员添加属性来对事件数据建立索引。</p>
<p>这是一个使用事件的合约的简单示例，每当计数器通过“increment”函数递增时，该合约就会发出一个事件：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod EventCounter {
    use starknet::{get_caller_address, ContractAddress};
    #[storage]
    struct Storage {
        // Counter value
        counter: u128,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    // The event enum must be annotated with the `#[event]` attribute.
    // It must also derive the `Drop` and `starknet::Event` traits.
    enum Event {
        CounterIncreased: CounterIncreased,
        UserIncreaseCounter: UserIncreaseCounter
    }

    // By deriving the `starknet::Event` trait, we indicate to the compiler that
    // this struct will be used when emitting events.
    #[derive(Drop, starknet::Event)]
    struct CounterIncreased {
        amount: u128
    }

    #[derive(Drop, starknet::Event)]
    struct UserIncreaseCounter {
        // The `#[key]` attribute indicates that this event will be indexed.
        #[key]
        user: ContractAddress,
        new_value: u128,
    }

    #[abi(per_item)]
    #[generate_trait]
    impl EventCounter of IEventCounter {
        #[external(v0)]
        fn increment(ref self: ContractState) {
            let mut counter = self.counter.read();
            counter += 1;
            self.counter.write(counter);
            // Emit event
            self.emit(Event::CounterIncreased(CounterIncreased { amount: 1 }));
            self
                .emit(
                    Event::UserIncreaseCounter(
                        UserIncreaseCounter {
                            user: get_caller_address(), new_value: self.counter.read()
                        }
                    )
                );
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x022e3B59518EA04aBb5da671ea04ecC3a154400f226d2Df38eFE146741b9E2F6">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/errors/src/custom_errors.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储自定义类型"><a class="header" href="#存储自定义类型">存储自定义类型</a></h1>
<p>虽然本机类型可以存储在合约的存储中而无需任何额外的工作，但自定义类型需要更多的工作。这是因为在编译时，编译器不知道如何在存储中存储自定义类型。<code>Store</code>为了解决这个问题，我们需要为我们的自定义类型实现该特征。希望我们可以为我们的自定义类型派生此特征 - 除非它包含数组或字典</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod StoringCustomType {
    #[storage]
    struct Storage {
        person: Person
    }

    // Deriving the starknet::Store trait
    // allows us to store the `Person` struct in the contract's storage.
    #[derive(Drop, starknet::Store)]
    struct Person {
        age: u8,
        name: felt252
    }

    #[abi(per_item)]
    #[generate_trait]
    impl StoringCustomType of IStoringCustomType {
        #[external(v0)]
        fn set_person(ref self: ContractState) {
            self.person.write(Person { age: 10, name: 'Joe' });
        }

        #[external(v0)]
        fn get_person(self: @ContractState) {
            self.person.read();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/storing_custom_types/src/contract.cairo">在Remix</a>中播放此合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入口点中的自定义类型"><a class="header" href="#入口点中的自定义类型">入口点中的自定义类型</a></h1>
<p>在入口点中使用自定义类型需要我们的类型来实现 <code>Serde</code> 特征。这是因为在调用入口点时，输入作为数组发送 <code>felt252</code> 到入口点，并且我们需要能够将其反序列化为我们的自定义类型。同样，当从入口点返回自定义类型时，我们需要能够将其序列化为 <code>felt252</code>。值得庆幸的是，我们可以导出 <code>Serde</code> 自定义类型的特征。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod SerdeCustomType {
    #[storage]
    struct Storage {}

    // Deriving the `Serde` trait allows us to use
    // the Person type as an entrypoint parameter and return value
    #[derive(Drop, Serde)]
    struct Person {
        age: u8,
        name: felt252
    }

    #[abi(per_item)]
    #[generate_trait]
    impl SerdeCustomType of ISerdeCustomType {
        #[external(v0)]
        fn person_input(ref self: ContractState, person: Person) {}

        #[external(v0)]
        fn person_output(self: @ContractState) -&gt; Person {
            Person { age: 10, name: 'Joe' }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/custom_type_serde/src/contract.cairo">在Remix</a>中播放此合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合约部署并与之交互"><a class="header" href="#合约部署并与之交互">合约部署并与之交互</a></h1>
<p>在本章中，我们将了解如何部署合约并与合约交互。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工厂模式"><a class="header" href="#工厂模式">工厂模式</a></h1>
<p>工厂模式是面向对象编程中众所周知的模式。它提供了如何实例化类的抽象。</p>
<p>对于智能合约，我们可以通过定义一个工厂合约来使用这种模式，该工厂合约全权负责创建和管理其他合约。</p>
<h2 id="类哈希和合约实例"><a class="header" href="#类哈希和合约实例">类哈希和合约实例</a></h2>
<p>在 Starknet 中，合约的类和实例之间是分离的。合约类充当蓝图，由底层 Cairo 字节码、合约的入口点、ABI 和 Sierra 程序哈希定义。合约类由类哈希来标识。当你想向网络添加一个新类时，你首先需要声明它。</p>
<p>部署合约时，您需要指定要部署的合约的类哈希。无论类哈希如何，合约的每个实例都有自己的存储。</p>
<p>使用工厂模式，我们可以部署同一合约类的多个实例并轻松处理升级。</p>
<h2 id="最小的例子"><a class="header" href="#最小的例子">最小的例子</a></h2>
<p>这是部署合约的工厂合约的最小示例<code>SimpleCounter</code>：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::{ContractAddress, ClassHash};

#[starknet::interface]
trait ICounterFactory&lt;TContractState&gt; {
    /// Create a new counter contract from stored arguments
    fn create_counter(ref self: TContractState) -&gt; ContractAddress;

    /// Create a new counter contract from the given arguments
    fn create_counter_at(ref self: TContractState, init_value: u128) -&gt; ContractAddress;

    /// Update the argument
    fn update_init_value(ref self: TContractState, init_value: u128);

    /// Update the class hash of the Counter contract to deploy when creating a new counter
    fn update_counter_class_hash(ref self: TContractState, counter_class_hash: ClassHash);
}

#[starknet::contract]
mod CounterFactory {
    use starknet::{ContractAddress, ClassHash};
    use starknet::syscalls::deploy_syscall;

    #[storage]
    struct Storage {
        /// Store the constructor arguments of the contract to deploy
        init_value: u128,
        /// Store the class hash of the contract to deploy
        counter_class_hash: ClassHash,
    }

    #[constructor]
    fn constructor(ref self: ContractState, init_value: u128, class_hash: ClassHash) {
        self.init_value.write(init_value);
        self.counter_class_hash.write(class_hash);
    }

    #[abi(embed_v0)]
    impl Factory of super::ICounterFactory&lt;ContractState&gt; {
        fn create_counter_at(ref self: ContractState, init_value: u128) -&gt; ContractAddress {
            // Constructor arguments
            let mut constructor_calldata: Array::&lt;felt252&gt; = array![init_value.into()];

            // Contract deployment
            let (deployed_address, _) = deploy_syscall(
                self.counter_class_hash.read(), 0, constructor_calldata.span(), false
            )
                .expect('failed to deploy counter');

            deployed_address
        }

        fn create_counter(ref self: ContractState) -&gt; ContractAddress {
            self.create_counter_at(self.init_value.read())
        }

        fn update_init_value(ref self: ContractState, init_value: u128) {
            self.init_value.write(init_value);
        }

        fn update_counter_class_hash(ref self: ContractState, counter_class_hash: ClassHash) {
            self.counter_class_hash.write(counter_class_hash);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>该工厂可用于<code>SimpleCounter</code>通过调用<code>create_counter</code>和<code>create_counter_at</code>函数来部署合约的多个实例。</p>
<p>类<code>SimpleCounter</code>哈希存储在工厂内部，并且可以使用允许在合约升级<code>update_counter_class_hash</code>时重用相同工厂合约的功能进行升级。<code>SimpleCounter</code></p>
<p>这个最小的示例缺乏一些有用的功能，例如访问控制、跟踪已部署的合约、事件……</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="合约接口和traits生成"><a class="header" href="#合约接口和traits生成">合约接口和Traits生成</a></h1>
<p>合约接口定义了合约的结构和行为，作为合约的公共 ABI。它们列出了合约公开的所有函数签名。接口的详细解释可以参考<a href="https://book.cairo-lang.org/ch99-01-02-a-simple-contract.html">Cairo Book</a>。</p>
<p>在开罗，要指定接口，您需要定义一个带有注释的特征<code>#[starknet::interface]</code>，然后在合约中实现该特征。</p>
<p>当函数需要访问合约状态时，它必须有一个self类型为 的参数ContractState。这意味着接口特征中相应的函数签名也必须采用类型<code>TContractState</code>作为参数。需要注意的是，合约接口中的每个函数都必须具有此self类型的参数TContractState。</p>
<p>您可以使用该<code>#[generate_trait]</code>属性隐式生成特定实现块的特征。该属性会自动生成一个与已实现块中的功能相同的特征，并用<code>self</code>通用参数替换该参数<code>TContractState</code>。</p>
<p>总的来说，处理接口有两种方法：</p>
<ul>
<li>明确地，通过定义一个带有注释的特征#[starknet::interface]</li>
<li>隐式地，通过使用#[generate_trait]属性</li>
</ul>
<h2 id="显式接口"><a class="header" href="#显式接口">显式接口</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait IExplicitInterfaceContract&lt;TContractState&gt; {
   fn get_value(self: @TContractState) -&gt; u32;
   fn set_value(ref self: TContractState, value: u32);
}

#[starknet::contract]
mod ExplicitInterfaceContract {
   #[storage]
   struct Storage {
       value: u32
   }

   #[abi(embed_v0)]
   impl ExplicitInterfaceContract of super::IExplicitInterfaceContract&lt;ContractState&gt; {
       fn get_value(self: @ContractState) -&gt; u32 {
           self.value.read()
       }

       fn set_value(ref self: ContractState, value: u32) {
           self.value.write(value);
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/interfaces_traits/src/explicit.cairo">在Remix</a>中播放此合约。</p>
<h2 id="隐式接口"><a class="header" href="#隐式接口">隐式接口</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod ImplicitInterfaceContract {
   #[storage]
   struct Storage {
       value: u32
   }

   #[abi(per_item)]
   #[generate_trait]
   impl ImplicitInterfaceContract of IImplicitInterfaceContract {
       #[external(v0)]
       fn get_value(self: @ContractState) -&gt; u32 {
           self.value.read()
       }

       #[external(v0)]
       fn set_value(ref self: ContractState, value: u32) {
           self.value.write(value);
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/interfaces_traits/src/implicit.cairo">在Remix</a>中播放此合约。</p>
<blockquote>
<p>注意：您可以使用导入隐式生成的合约接口 <code>use contract::{GeneratedContractInterface}</code>。但是，<code>Dispatcher</code> 不会自动生成。</p>
</blockquote>
<h2 id="内部功能"><a class="header" href="#内部功能">内部功能</a></h2>
<p>您也可以用于<code>#[generate_trait]</code>您的内部功能。由于此特征是在合约上下文中生成的，因此您也可以定义纯函数（不带参数的函数<code>self</code>）。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait IImplicitInternalContract&lt;TContractState&gt; {
    fn add(ref self: TContractState, nb: u32);
    fn get_value(self: @TContractState) -&gt; u32;
    fn get_const(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
mod ImplicitInternalContract {
    use super::IImplicitInternalContract;

    #[storage]
    struct Storage {
        value: u32
    }

    #[generate_trait]
    impl InternalFunctions of InternalFunctionsTrait {
        #[external(v0)]
        fn set_value(ref self: ContractState, value: u32) {
            self.value.write(value);
        }
        fn get_const() -&gt; u32 {
            42
        }
    }

    #[constructor]
    fn constructor(ref self: ContractState) {
        self.set_value(0);
    }

    #[abi(embed_v0)]
    impl ImplicitInternalContract of IImplicitInternalContract&lt;ContractState&gt; {
        fn add(ref self: ContractState, nb: u32) {
            self.set_value(self.value.read() + nb);
        }
        fn get_value(self: @ContractState) -&gt; u32 {
            self.value.read()
        }
        fn get_const(self: @ContractState) -&gt; u32 {
            self.get_const()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/interfaces_traits/src/implicit_internal.cairo">在Remix</a>中播放此合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调用其他合约"><a class="header" href="#调用其他合约">调用其他合约</a></h1>
<p>在Cairo有两种不同的方式调用其他合约。</p>
<p>调用其他合约的最简单方法是使用您要调用的合约的调度程序。<a href="https://cairo-book.github.io/ch99-02-02-contract-dispatcher-library-dispatcher-and-system-calls.html#contract-dispatcher">您可以在Cairo书中</a>阅读有关调度员的更多信息</p>
<p>另一种方法是自己使用<code>starknet::call_contract_syscall</code>系统调用。但是，不建议使用此方法。</p>
<p>为了使用调度程序调用其他合约，您需要将被调用合约的接口定义为使用属性注释的特征<code>#[starknet::interface]</code>，然后在合约中导入<code>IContractDispatcher</code>和项目。<code>IContractDispatcherTrait</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod Callee {
   #[storage]
   struct Storage {
       value: u128,
   }

   #[abi(per_item)]
   #[generate_trait]
   impl ICalleeImpl of ICallee {
       fn set_value(ref self: ContractState, value: u128) -&gt; u128 {
           self.value.write(value);
           value
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x015c3Bb6D0DE26b64FEAF9A8f4655CfADb5c128bF4510398972704ee12775DB1">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/calling_other_contracts/src/callee.cairo">Remix</a>中使用它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::ContractAddress;

// We need to have the interface of the callee contract defined
// so that we can import the Dispatcher.
#[starknet::interface]
trait ICallee&lt;TContractState&gt; {
   fn set_value(ref self: TContractState, value: u128) -&gt; u128;
}

#[starknet::contract]
mod Caller {
   // We import the Dispatcher of the called contract
   use super::{ICalleeDispatcher, ICalleeDispatcherTrait};
   use starknet::ContractAddress;

   #[storage]
   struct Storage {}

   #[abi(per_item)]
   #[generate_trait]
   impl ICallerImpl of ICaller {
       fn set_value_from_address(ref self: ContractState, addr: ContractAddress, value: u128) {
           ICalleeDispatcher { contract_address: addr }.set_value(value);
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x05fa8aF796343d2f22c53C17149386b67B7AC4aB52D9e308Aa507C185aA44778">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/calling_other_contracts/src/caller.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试合约"><a class="header" href="#测试合约">测试合约</a></h1>
<p>测试在软件开发中起着至关重要的作用，尤其是智能合约。在本节中，我们将指导您了解在 Starknet 上使用<code>scarb</code>.</p>
<p>我们先以一个简单的智能合约为例：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::ContractAddress;

#[starknet::interface]
trait ISimpleContract&lt;TContractState&gt; {
   fn get_value(self: @TContractState) -&gt; u32;
   fn get_owner(self: @TContractState) -&gt; ContractAddress;
   fn set_value(ref self: TContractState, value: u32);
}

#[starknet::contract]
mod SimpleContract {
   use starknet::{get_caller_address, ContractAddress};

   #[storage]
   struct Storage {
       value: u32,
       owner: ContractAddress
   }

   #[constructor]
   fn constructor(ref self: ContractState, initial_value: u32) {
       self.value.write(initial_value);
       self.owner.write(get_caller_address());
   }

   #[abi(embed_v0)]
   impl SimpleContract of super::ISimpleContract&lt;ContractState&gt; {
       fn get_value(self: @ContractState) -&gt; u32 {
           self.value.read()
       }

       fn get_owner(self: @ContractState) -&gt; ContractAddress {
           self.owner.read()
       }

       fn set_value(ref self: ContractState, value: u32) {
           assert(self.owner.read() == get_caller_address(), 'Not owner');
           self.value.write(value);
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p>现在，看一下这个合约的测试：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
   // Import the interface and dispatcher to be able to interact with the contract.
   use sbe_testing::contract::{
       ISimpleContract, SimpleContract, ISimpleContractDispatcher, ISimpleContractDispatcherTrait
   };

   // Import the deploy syscall to be able to deploy the contract.
   use starknet::class_hash::Felt252TryIntoClassHash;
   use starknet::{
       deploy_syscall, ContractAddress, get_caller_address, get_contract_address,
       contract_address_const
   };

   // Use starknet test utils to fake the transaction context.
   use starknet::testing::{set_caller_address, set_contract_address};

   // Deploy the contract and return its dispatcher.
   fn deploy(initial_value: u32) -&gt; ISimpleContractDispatcher {
       // Set up constructor arguments.
       let mut calldata = ArrayTrait::new();
       initial_value.serialize(ref calldata);

       // Declare and deploy
       let (contract_address, _) = deploy_syscall(
           SimpleContract::TEST_CLASS_HASH.try_into().unwrap(), 0, calldata.span(), false
       )
           .unwrap();

       // Return the dispatcher.
       // The dispatcher allows to interact with the contract based on its interface.
       ISimpleContractDispatcher { contract_address }
   }

   #[test]
   #[available_gas(2000000000)]
   fn test_deploy() {
       let initial_value: u32 = 10;
       let contract = deploy(initial_value);

       assert(contract.get_value() == initial_value, 'wrong initial value');
       assert(contract.get_owner() == get_contract_address(), 'wrong owner');
   }

   #[test]
   #[available_gas(2000000000)]
   fn test_set_as_owner() {
       // Fake the caller address to address 1
       let owner = contract_address_const::&lt;1&gt;();
       set_contract_address(owner);

       let contract = deploy(10);
       assert(contract.get_owner() == owner, 'wrong owner');

       // Fake the contract address to address 1
       set_contract_address(owner);
       let new_value: u32 = 20;
       contract.set_value(new_value);

       assert(contract.get_value() == new_value, 'wrong value');
   }

   #[test]
   #[should_panic]
   #[available_gas(2000000000)]
   fn test_set_not_owner() {
       let owner = contract_address_const::&lt;1&gt;();
       set_contract_address(owner);

       let contract = deploy(10);

       let not_owner = contract_address_const::&lt;2&gt;();
       set_contract_address(not_owner);

       let new_value: u32 = 20;
       contract.set_value(new_value);
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch00-getting-started/testing/src/lib.cairo">在Remix</a>中播放此合约。</p>
<p>为了定义我们的测试，我们使用 scrapb，它允许我们创建一个用<code>#[cfg(test)]</code>. 这可确保仅在使用 运行测试时才编译测试模块<code>scarb test</code>。</p>
<p>每个测试都被定义为具有属性的函数<code>#[test]</code>。您还可以使用该属性检查测试是否出现恐慌<code>#[should_panic]</code>。</p>
<p>由于我们处于智能合约的背景下，因此设置 Gas 限制至关重要。您可以通过使用<code>#[available_gas(X)]</code>属性来指定测试的气体限制来完成此操作。这也是确保合约功能保持在一定 Gas 限制以下的好方法！</p>
<blockquote>
<p>注意：这里的“gas”指的是Sierragas，而不是L1gas</p>
</blockquote>
<p>现在，让我们继续测试过程：</p>
<ul>
<li>使用<code>deploy</code>函数逻辑来声明和部署您的合约。</li>
<li>用于<code>assert</code>验证合约在给定上下文中的行为是否符合预期。</li>
</ul>
<p>为了让测试更加方便，testingcorelib模块提供了一些有用的函数：</p>
<ul>
<li><code>set_caller_address(address: ContractAddress)</code></li>
<li><code>set_contract_address(address: ContractAddress)</code></li>
<li><code>set_block_number(block_number: u64)</code></li>
<li><code>set_block_timestamp(block_timestamp: u64)</code></li>
<li><code>set_account_contract_address(address: ContractAddress)</code></li>
<li><code>set_max_fee(fee: u128)</code></li>
</ul>
<p>您可能还需要<code>infocorelib</code> 中的模块，它允许您访问有关当前事务上下文的信息：</p>
<ul>
<li><code>get_caller_address() -&gt; ContractAddress</code></li>
<li><code>get_contract_address() -&gt; ContractAddress</code></li>
<li><code>get_block_info() -&gt; Box&lt;BlockInfo&gt;</code></li>
<li><code>get_tx_info() -&gt; Box&lt;TxInfo&gt;</code></li>
<li><code>get_block_timestamp() -&gt; u64</code></li>
<li><code>get_block_number() -&gt; u64</code></li>
</ul>
<p><a href="https://github.com/starkware-libs/cairo/tree/main/corelib/src/starknet">您可以在Starknet Corelib 存储库</a>中找到完整的函数列表。<a href="https://book.cairo-lang.org/ch08-01-how-to-write-tests.html">您还可以在Cairo 书第 8 章</a>中找到关于 cairo 测试的详细说明。</p>
<h2 id="starknet-铸造厂"><a class="header" href="#starknet-铸造厂">Starknet 铸造厂</a></h2>
<p>Starknet Foundry 是一个用于在 Starknet 上开发智能合约的强大工具包。scarb它提供了在该工具之上测试 Starknet 智能合约的支持Forge。</p>
<p>测试与snforge我们刚刚描述的过程类似，但经过简化。此外，其他功能正在开发中，包括作弊代码或并行测试执行。我们强烈建议探索 Starknet Foundry 并将其合并到您的项目中。</p>
<p>有关使用 Starknet Foundry 测试合约的更多详细信息，<a href="https://foundry-rs.github.io/starknet-foundry/testing/contracts.html">请查看Starknet Foundry 书籍 - 测试合约</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cairo备忘单"><a class="header" href="#cairo备忘单">Cairo备忘单</a></h1>
<p>本章旨在为最常见的 Cairo 结构提供快速参考。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="felt252"><a class="header" href="#felt252">Felt252</a></h1>
<p>Felt252 是 Cairo 的基本数据类型，所有其他数据类型均源自该类型。Felt252 还可用于存储最大长度为 31 个字符的短字符串表示形式。</p>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod feltExample {
   use starknet::{ContractAddress, get_caller_address};

   #[storage]
   struct Storage {
       userName: LegacyMap::&lt;ContractAddress, felt252&gt;,
   }

   #[external(v0)]
   #[generate_trait]
   impl external of externlalTrait {
       fn storeName(ref self: ContractState, name: felt252) -&gt; felt252 {
           self.userName.write(get_caller_address(), name);

           let welcomeMsg: felt252 = 'Welcome to StarknetByExample';
           welcomeMsg
       }

       fn viewName(self: @ContractState, Add: ContractAddress) -&gt; felt252 {
           self.userName.read(Add)
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mapping"><a class="header" href="#mapping">Mapping</a></h1>
<p>该<code>LegacyMap</code>类型可用于表示键值的集合。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod mappingContract {
   use starknet::ContractAddress;

   #[storage]
   struct Storage {
       studentsName: LegacyMap::&lt;ContractAddress, felt252&gt;,
       studentsResultRecord: LegacyMap::&lt;(ContractAddress, felt252), u16&gt;,
   }

   #[external(v0)]
   #[generate_trait]
   impl external of externalTrait {
       fn registerUser(
           ref self: ContractState, studentAdd: ContractAddress, studentName: felt252
       ) {
           self.studentsName.write(studentAdd, studentName);
       }

       fn recordStudentScore(
           ref self: ContractState, studentAdd: ContractAddress, Subject: felt252, score: u16
       ) {
           self.studentsResultRecord.write((studentAdd, Subject), score);
       }

       fn viewStudentName(self: @ContractState, studentAdd: ContractAddress) -&gt; felt252 {
           self.studentsName.read(studentAdd)
       }

       fn viewStudentScore(
           self: @ContractState, studentAdd: ContractAddress, Subject: felt252
       ) -&gt; u16 {
           // for a 2D mapping its important to take note of the amount of brackets being used.
           self.studentsResultRecord.read((studentAdd, Subject))
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数组"><a class="header" href="#数组">数组</a></h1>
<p>数组是相同类型元素的集合。数组上可能的操作由<code>array::ArrayTrait</code> corelib 定义：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ArrayTrait&lt;T&gt; {
   fn new() -&gt; Array&lt;T&gt;;
   fn append(ref self: Array&lt;T&gt;, value: T);
   fn pop_front(ref self: Array&lt;T&gt;) -&gt; Option&lt;T&gt; nopanic;
   fn pop_front_consume(self: Array&lt;T&gt;) -&gt; Option&lt;(Array&lt;T&gt;, T)&gt; nopanic;
   fn get(self: @Array&lt;T&gt;, index: usize) -&gt; Option&lt;Box&lt;@T&gt;&gt;;
   fn at(self: @Array&lt;T&gt;, index: usize) -&gt; @T;
   fn len(self: @Array&lt;T&gt;) -&gt; usize;
   fn is_empty(self: @Array&lt;T&gt;) -&gt; bool;
   fn span(self: @Array&lt;T&gt;) -&gt; Span&lt;T&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod arrayExample {
   #[storage]
   struct Storage {}


   #[external(v0)]
   #[generate_trait]
   impl external of externalTrait {
       fn createArray(self: @ContractState, numOne: u32, numTwo: u32, numThree: u32) -&gt; bool {
           let mut Arr = ArrayTrait::&lt;u32&gt;::new();
           Arr.append(numOne);
           Arr.append(numTwo);
           Arr.append(numThree);

           let ArrLength: usize = Arr.len();
           assert(ArrLength == 3, 'Array Length should be 3');

           let first_value = Arr.pop_front().unwrap();
           assert(first_value == numOne, 'Both values should match');

           let second_value = *Arr.at(0);
           assert(second_value == numTwo, 'Both values should match too');

           //Returns true if an array is empty, then false if it isn't.
           Arr.is_empty()
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环"><a class="header" href="#循环">循环</a></h1>
<p>循环指定将重复运行直到遇到停止条件的代码块。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod loopExample {
    #[storage]
    struct Storage {}

    #[external(v0)]
    #[generate_trait]
    impl external of externlalTrait {
        fn gatherEvens(ref self: ContractState, maxLimit: u32) -&gt; Array&lt;u32&gt; {
            let mut i: u32 = 0;
            let mut Arr = ArrayTrait::new();
            loop {
                if i == maxLimit {
                    break;
                };
                if (i % 2 == 0) {
                    Arr.append(i);
                }
                i += 1;
            };

            return Arr;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">Match</a></h1>
<p>Cairo 中的“Match”表达式允许我们通过将felt数据类型或enum与各种模式进行比较，然后根据匹配的模式运行特定代码来控制代码流。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod matchExample {
   #[storage]
   struct Storage {}

   #[derive(Drop, Serde)]
   enum Colour {
       Red,
       Blue,
       Green,
       Orange,
       Black
   }

   #[derive(Drop, Serde)]
   enum Coin {
       Penny,
       Nickel,
       Dime,
       Quarter,
   }

   #[external(v0)]
   #[generate_trait]
   impl external of externlalTrait {
       fn value_in_cents(self: @ContractState, coin: Coin) -&gt; felt252 {
           match coin {
               Coin::Penny =&gt; 1,
               Coin::Nickel =&gt; 5,
               Coin::Dime =&gt; 10,
               Coin::Quarter =&gt; 25,
           }
       }

       fn specified_colour(self: @ContractState, colour: Colour) -&gt; felt252 {
           let mut response: felt252 = '';

           match colour {
               Colour::Red =&gt; { response = 'You passed in Red';},
               Colour::Blue =&gt; { response = 'You passed in Blue'; },
               Colour::Green =&gt; { response = 'You passed in Green'; },
               Colour::Orange =&gt; { response = 'You passed in Orange'; },
               Colour::Black =&gt; { response = 'You passed in Black'; },
           };

           response
       }

       fn quiz(self: @ContractState, num: felt252) -&gt; felt252 {
           let mut response: felt252 = '';

           match num {
               0 =&gt; { response = 'You failed' },
               _ =&gt; { response = 'You Passed' },
           };

           response
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<p>结构体是一种类似于元组的数据类型。与元组一样，它们可用于保存不同类型的数据。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod StructExample {
   use starknet::{ContractAddress, get_caller_address};

   #[storage]
   struct Storage {
       userData: data
   }

   #[derive(Drop, starknet::Store)]
   struct data {
       Add: ContractAddress,
       Age: u8
   }

   #[external(v0)]
   #[generate_trait]
   impl StoreStructImpl of IStoreStructContract {
       fn store_struct(ref self: ContractState, age: u8) {
           let newStruct = data { Add: get_caller_address(), Age: age };
           self.userData.write(newStruct);
       }

       fn read_struct(self: @ContractState) -&gt; (ContractAddress, u8) {
           let lastUser = self.userData.read();
           let add = lastUser.Add;
           let age = lastUser.Age;
           (add, age)
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h1>
<p>Cairo 支持使用 into 和 try_into 方法从一种标量类型转换为另一种标量类型。 <code>traits::Into</code>用于从较小的数据类型转换为较大的数据类型，而<code>traits::TryInto</code>用于从较大的数据类型转换为可能不适合的较小的类型。例如：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod typecasting_Example {
   #[storage]
   struct Storage {}

   #[external(v0)]
   #[generate_trait]
   impl external of externlalTrait {
       fn typeCasting(self: @ContractState, randNumber: u32) {
           let my_felt252 = 15;

           // Since a u32 might not fit in a u8 and a u16, we need to use try_into,
           // then unwrap the Option&lt;T&gt; type thats returned.
           let new_u8: u8 = randNumber.try_into().unwrap();
           let new_u16: u16 = randNumber.try_into().unwrap();

           // since new_u32 is the of the same type (u32) as randNumber, we can directly assign them,
           // or use the .into() method.
           let new_u32: u32 = randNumber;

           // When typecasting from a smaller size to an equal or larger size we use the .into() method.
           // Note: u64 and u128 are larger than u32, so a u32 type will always fit into them.
           let new_u64: u64 = randNumber.into();
           let new_u128: u128 = randNumber.into();

           // Since a felt252 is smaller than a u256, we can use the into() method
           let new_u256: u256 = my_felt252.into();
           let new_felt252: felt252 = new_u16.into();

           //note a usize is smaller than a felt so we use the try_into
           let new_usize: usize = my_felt252.try_into().unwrap();
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可升级合约"><a class="header" href="#可升级合约">可升级合约</a></h1>
<p>在Starknet中，合约分为两部分：合约类和合约实例。这种划分遵循面向对象编程语言中使用的类似概念，其中我们区分对象的定义和实现。</p>
<p>合约类是合约的定义：它指定合约的行为方式。它包含基本信息，如开罗字节码、提示信息、入口点名称以及明确定义其语义的所有内容。</p>
<p>为了识别不同的合约类别，Starknet 为每个类别分配了一个唯一的标识符：类别哈希。合约实例是一个已部署的合约，对应于特定的合约类。将其视为 Java 等语言中的对象实例。</p>
<p>每个类都通过其类哈希来标识，这类似于面向对象编程语言中的类名。合约实例是一个类对应的部署合约。</p>
<p>您可以通过调用该函数将已部署的合约升级到新版本<code>replace_class_syscall</code>。通过使用此函数，您可以更新与已部署合约关联的类哈希，从而有效地升级其实现。但是，这不会修改合约的存储，因此合约中存储的所有数据将保持不变。</p>
<p>为了说明这个概念，让我们考虑一个包含两个合约的示例：<code>UpgradeableContract_V0</code>、 和<code>UpgradeableContract_V1</code>。首先部署<code>UpgradeableContract_V0</code>为初始版本。接下来，发送一个调用该upgrade函数的交易，以 的类哈希作为<code>UpgradeableContract_V1</code>参数，将已部署合约的类哈希升级为 1 <code>UpgradeableContract_V1</code>。然后调用<code>version</code>合约上的方法可以看到合约已经升级到了V1版本。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::class_hash::ClassHash;

#[starknet::interface]
trait IUpgradeableContract&lt;TContractState&gt; {
   fn upgrade(ref self: TContractState, impl_hash: ClassHash);
   fn version(self: @TContractState) -&gt; u8;
}

#[starknet::contract]
mod UpgradeableContract_V0 {
   use starknet::class_hash::ClassHash;
   use starknet::SyscallResultTrait;

   #[storage]
   struct Storage {}


   #[event]
   #[derive(Drop, starknet::Event)]
   enum Event {
       Upgraded: Upgraded
   }

   #[derive(Drop, starknet::Event)]
   struct Upgraded {
       implementation: ClassHash
   }

   #[abi(embed_v0)]
   impl UpgradeableContract of super::IUpgradeableContract&lt;ContractState&gt; {
       fn upgrade(ref self: ContractState, impl_hash: ClassHash) {
           assert(!impl_hash.is_zero(), 'Class hash cannot be zero');
           starknet::replace_class_syscall(impl_hash).unwrap_syscall();
           self.emit(Event::Upgraded(Upgraded { implementation: impl_hash }))
       }

       fn version(self: @ContractState) -&gt; u8 {
           0
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x005300003ade5d10447d941a42d48b7141074cd8bade2b16520684896a5090ea">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch01-applications/upgradeable_contract/src/upgradeable_contract_v0.cairo">Remix</a>中使用它。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::class_hash::ClassHash;

#[starknet::interface]
trait IUpgradeableContract&lt;TContractState&gt; {
   fn upgrade(ref self: TContractState, impl_hash: ClassHash);
   fn version(self: @TContractState) -&gt; u8;
}

#[starknet::contract]
mod UpgradeableContract_V1 {
   use starknet::class_hash::ClassHash;
   use starknet::SyscallResultTrait;

   #[storage]
   struct Storage {}


   #[event]
   #[derive(Drop, starknet::Event)]
   enum Event {
       Upgraded: Upgraded
   }

   #[derive(Drop, starknet::Event)]
   struct Upgraded {
       implementation: ClassHash
   }

   #[abi(embed_v0)]
   impl UpgradeableContract of super::IUpgradeableContract&lt;ContractState&gt; {
       fn upgrade(ref self: ContractState, impl_hash: ClassHash) {
           assert(!impl_hash.is_zero(), 'Class hash cannot be zero');
           starknet::replace_class_syscall(impl_hash).unwrap_syscall();
           self.emit(Event::Upgraded(Upgraded { implementation: impl_hash }))
       }

       fn version(self: @ContractState) -&gt; u8 {
           1
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x017c86152badd1d665b9836571bd6b0a484f028748aa13d9b2d5d9c9192fafc6">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch01-applications/upgradeable_contract/src/upgradeable_contract_v1.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简单的-defi-vault"><a class="header" href="#简单的-defi-vault">简单的 Defi Vault</a></h1>
<p><a href="https://solidity-by-example.org/defi/vault/">这是Solidity by example Vault 的</a>Cairo版本。它的工作原理如下：</p>
<ul>
<li>
<p>当用户存入代币时，合约会计算要铸造的股份数量。</p>
</li>
<li>
<p>当用户提款时，合约会销毁他们的股份，计算收益率，并提取收益率和初始存入的代币金额。</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use starknet::{ContractAddress};

// In order to make contract calls within our Vault,
// we need to have the interface of the remote ERC20 contract defined to import the Dispatcher.
#[starknet::interface]
trait IERC20&lt;TContractState&gt; {
   fn name(self: @TContractState) -&gt; felt252;
   fn symbol(self: @TContractState) -&gt; felt252;
   fn decimals(self: @TContractState) -&gt; u8;
   fn total_supply(self: @TContractState) -&gt; u256;
   fn balance_of(self: @TContractState, account: ContractAddress) -&gt; u256;
   fn allowance(self: @TContractState, owner: ContractAddress, spender: ContractAddress) -&gt; u256;
   fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -&gt; bool;
   fn transfer_from(
       ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256
   ) -&gt; bool;
   fn approve(ref self: TContractState, spender: ContractAddress, amount: u256) -&gt; bool;
}

#[starknet::interface]
trait ISimpleVault&lt;TContractState&gt; {
   fn deposit(ref self: TContractState, amount: u256);
   fn withdraw(ref self: TContractState, shares: u256);
}

#[starknet::contract]
mod SimpleVault {
   use super::{IERC20Dispatcher, IERC20DispatcherTrait};
   use starknet::{ContractAddress, get_caller_address, get_contract_address};
   #[storage]
   struct Storage {
       token: IERC20Dispatcher,
       total_supply: u256,
       balance_of: LegacyMap&lt;ContractAddress, u256&gt;
   }

   #[constructor]
   fn constructor(ref self: ContractState, token: ContractAddress) {
       self.token.write(IERC20Dispatcher { contract_address: token });
   }

   #[generate_trait]
   impl PrivateFunctions of PrivateFunctionsTrait {
       fn _mint(ref self: ContractState, to: ContractAddress, shares: u256) {
           self.total_supply.write(self.total_supply.read() + shares);
           self.balance_of.write(to, self.balance_of.read(to) + shares);
       }

       fn _burn(ref self: ContractState, from: ContractAddress, shares: u256) {
           self.total_supply.write(self.total_supply.read() - shares);
           self.balance_of.write(from, self.balance_of.read(from) - shares);
       }
   }

   #[abi(embed_v0)]
   impl SimpleVault of super::ISimpleVault&lt;ContractState&gt; {
       fn deposit(ref self: ContractState, amount: u256) {
           // a = amount
           // B = balance of token before deposit
           // T = total supply
           // s = shares to mint
           //
           // (T + s) / T = (a + B) / B 
           //
           // s = aT / B
           let caller = get_caller_address();
           let this = get_contract_address();

           let mut shares = 0;
           if self.total_supply.read() == 0 {
               shares = amount;
           } else {
               let balance = self.token.read().balance_of(this);
               shares = (amount * self.total_supply.read()) / balance;
           }

           PrivateFunctions::_mint(ref self, caller, shares);
           self.token.read().transfer_from(caller, this, amount);
       }

       fn withdraw(ref self: ContractState, shares: u256) {
           // a = amount
           // B = balance of token before withdraw
           // T = total supply
           // s = shares to burn
           //
           // (T - s) / T = (B - a) / B 
           //
           // a = sB / T
           let caller = get_caller_address();
           let this = get_contract_address();

           let balance = self.token.read().balance_of(this);
           let amount = (shares * balance) / self.total_supply.read();
           PrivateFunctions::_burn(ref self, caller, shares);
           self.token.read().transfer(caller, amount);
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch01-applications/simple_vault/src/simple_vault.cairo">在Remix</a>中播放此合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc20代币"><a class="header" href="#erc20代币">ERC20代币</a></h1>
<p>遵循<a href="https://eips.ethereum.org/EIPS/eip-20">ERC20 标准</a>的合约称为 ERC20 代币。它们用于代表可替代资产。</p>
<p>要创建ERC20合约，必须实现以下接口：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait IERC20&lt;TContractState&gt; {
   fn get_name(self: @TContractState) -&gt; felt252;
   fn get_symbol(self: @TContractState) -&gt; felt252;
   fn get_decimals(self: @TContractState) -&gt; u8;
   fn get_total_supply(self: @TContractState) -&gt; felt252;
   fn balance_of(self: @TContractState, account: ContractAddress) -&gt; felt252;
   fn allowance(
       self: @TContractState, owner: ContractAddress, spender: ContractAddress
   ) -&gt; felt252;
   fn transfer(ref self: TContractState, recipient: ContractAddress, amount: felt252);
   fn transfer_from(
       ref self: TContractState,
       sender: ContractAddress,
       recipient: ContractAddress,
       amount: felt252
   );
   fn approve(ref self: TContractState, spender: ContractAddress, amount: felt252);
   fn increase_allowance(ref self: TContractState, spender: ContractAddress, added_value: felt252);
   fn decrease_allowance(
       ref self: TContractState, spender: ContractAddress, subtracted_value: felt252
   );
}
<span class="boring">}</span></code></pre></pre>
<p>在 Starknet 中，函数名称应该写成Snake_case。Solidity 中的情况并非如此，函数名称以驼峰命名法编写。因此，Starknet ERC20 接口与 Solidity ERC20 接口略有不同。</p>
<p>这是 ERC20 接口在开罗的实现：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::contract]
mod erc20 {
   use zeroable::Zeroable;
   use starknet::get_caller_address;
   use starknet::contract_address_const;
   use starknet::ContractAddress;

   #[storage]
   struct Storage {
       name: felt252,
       symbol: felt252,
       decimals: u8,
       total_supply: felt252,
       balances: LegacyMap::&lt;ContractAddress, felt252&gt;,
       allowances: LegacyMap::&lt;(ContractAddress, ContractAddress), felt252&gt;,
   }

   #[event]
   #[derive(Drop, starknet::Event)]
   enum Event {
       Transfer: Transfer,
       Approval: Approval,
   }
   #[derive(Drop, starknet::Event)]
   struct Transfer {
       from: ContractAddress,
       to: ContractAddress,
       value: felt252,
   }
   #[derive(Drop, starknet::Event)]
   struct Approval {
       owner: ContractAddress,
       spender: ContractAddress,
       value: felt252,
   }

   mod Errors {
       const APPROVE_FROM_ZERO: felt252 = 'ERC20: approve from 0';
       const APPROVE_TO_ZERO: felt252 = 'ERC20: approve to 0';
       const TRANSFER_FROM_ZERO: felt252 = 'ERC20: transfer from 0';
       const TRANSFER_TO_ZERO: felt252 = 'ERC20: transfer to 0';
       const BURN_FROM_ZERO: felt252 = 'ERC20: burn from 0';
       const MINT_TO_ZERO: felt252 = 'ERC20: mint to 0';
   }

   #[constructor]
   fn constructor(
       ref self: ContractState,
       recipient: ContractAddress,
       name: felt252,
       decimals: u8,
       initial_supply: felt252,
       symbol: felt252
   ) {
       self.name.write(name);
       self.symbol.write(symbol);
       self.decimals.write(decimals);
       self.mint(recipient, initial_supply);
   }

   #[external(v0)]
   impl IERC20Impl of super::IERC20&lt;ContractState&gt; {
       fn get_name(self: @ContractState) -&gt; felt252 {
           self.name.read()
       }

       fn get_symbol(self: @ContractState) -&gt; felt252 {
           self.symbol.read()
       }

       fn get_decimals(self: @ContractState) -&gt; u8 {
           self.decimals.read()
       }

       fn get_total_supply(self: @ContractState) -&gt; felt252 {
           self.total_supply.read()
       }

       fn balance_of(self: @ContractState, account: ContractAddress) -&gt; felt252 {
           self.balances.read(account)
       }

       fn allowance(
           self: @ContractState, owner: ContractAddress, spender: ContractAddress
       ) -&gt; felt252 {
           self.allowances.read((owner, spender))
       }

       fn transfer(ref self: ContractState, recipient: ContractAddress, amount: felt252) {
           let sender = get_caller_address();
           self._transfer(sender, recipient, amount);
       }

       fn transfer_from(
           ref self: ContractState,
           sender: ContractAddress,
           recipient: ContractAddress,
           amount: felt252
       ) {
           let caller = get_caller_address();
           self.spend_allowance(sender, caller, amount);
           self._transfer(sender, recipient, amount);
       }

       fn approve(ref self: ContractState, spender: ContractAddress, amount: felt252) {
           let caller = get_caller_address();
           self.approve_helper(caller, spender, amount);
       }

       fn increase_allowance(
           ref self: ContractState, spender: ContractAddress, added_value: felt252
       ) {
           let caller = get_caller_address();
           self
               .approve_helper(
                   caller, spender, self.allowances.read((caller, spender)) + added_value
               );
       }

       fn decrease_allowance(
           ref self: ContractState, spender: ContractAddress, subtracted_value: felt252
       ) {
           let caller = get_caller_address();
           self
               .approve_helper(
                   caller, spender, self.allowances.read((caller, spender)) - subtracted_value
               );
       }
   }

   #[generate_trait]
   impl InternalImpl of InternalTrait {
       fn _transfer(
           ref self: ContractState,
           sender: ContractAddress,
           recipient: ContractAddress,
           amount: felt252
       ) {
           assert(!sender.is_zero(), Errors::TRANSFER_FROM_ZERO);
           assert(!recipient.is_zero(), Errors::TRANSFER_TO_ZERO);
           self.balances.write(sender, self.balances.read(sender) - amount);
           self.balances.write(recipient, self.balances.read(recipient) + amount);
           self.emit(Transfer { from: sender, to: recipient, value: amount });
       }

       fn spend_allowance(
           ref self: ContractState,
           owner: ContractAddress,
           spender: ContractAddress,
           amount: felt252
       ) {
           let allowance = self.allowances.read((owner, spender));
           self.allowances.write((owner, spender), allowance - amount);
       }

       fn approve_helper(
           ref self: ContractState,
           owner: ContractAddress,
           spender: ContractAddress,
           amount: felt252
       ) {
           assert(!spender.is_zero(), Errors::APPROVE_TO_ZERO);
           self.allowances.write((owner, spender), amount);
           self.emit(Approval { owner, spender, value: amount });
       }

       fn mint(ref self: ContractState, recipient: ContractAddress, amount: felt252) {
           assert(!recipient.is_zero(), Errors::MINT_TO_ZERO);
           let supply = self.total_supply.read() + amount; // What can go wrong here?
           self.total_supply.write(supply);
           let balance = self.balances.read(recipient) + amount;
           self.balances.write(recipient, amount);
           self
               .emit(
                   Event::Transfer(
                       Transfer {
                           from: contract_address_const::&lt;0&gt;(), to: recipient, value: amount
                       }
                   )
               );
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch01-applications/erc20/src/token.cairo">在Remix</a>中播放此合约。</p>
<p>还有其他几种实现，例如<a href="https://docs.openzeppelin.com/contracts-cairo/0.7.0/erc20">Open Zeppelin</a>或<a href="https://cairo-by-example.com/examples/erc20/">Cairo By Examples</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="恒定乘积-amm"><a class="header" href="#恒定乘积-amm">恒定乘积 AMM</a></h1>
<p><a href="https://solidity-by-example.org/defi/constant-product-amm/">这是通过示例 Constant Product AMM 对 Solidity</a>进行的Cairo改编。</p>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch01-applications/constant_product_amm/src/constant_product_amm.cairo">在Remix</a>中播放此合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="写入任意村粗槽"><a class="header" href="#写入任意村粗槽">写入任意村粗槽</a></h1>
<p>在 Starknet 上，合约的存储是一个包含 2^251 个槽的映射，其中每个槽都是一个初始化为 0 的felt。存储变量的地址在编译时使用以下公式计算：<code>storage variable address := pedersen(keccak(variable name), keys)</code>。与存储变量的交互通常使用<code>self.var.read()</code>和<code>self.var.write()</code>函数来执行。</p>
<p>尽管如此，我们可以使用<code>storage_write_syscall</code>和<code>storage_read_syscall</code>系统调用来写入和读取任何存储槽。这在写入编译时未知的存储变量时很有用，或者确保即使合约升级并且存储变量地址的计算方法发生变化，它们仍然可以访问。</p>
<p>在下面的示例中，我们使用 Poseidon 哈希函数来计算存储变量的地址。Poseidon 是一种 ZK 友好的哈希函数，比 Pedersen 更便宜、更快，使其成为链上计算的绝佳选择。一旦计算出地址，我们就使用存储系统调用与其交互。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait IWriteToAnySlots&lt;TContractState&gt; {
   fn write_slot(ref self: TContractState, value: u32);
   fn read_slot(self: @TContractState) -&gt; u32;
}

#[starknet::contract]
mod WriteToAnySlot {
   use starknet::syscalls::{storage_read_syscall, storage_write_syscall};
   use starknet::SyscallResultTrait;
   use poseidon::poseidon_hash_span;
   use starknet::storage_access::Felt252TryIntoStorageAddress;
   use starknet::StorageAddress;

   #[storage]
   struct Storage {}

   const SLOT_NAME: felt252 = 'test_slot';

   #[abi(embed_v0)]
   impl WriteToAnySlot of super::IWriteToAnySlots&lt;ContractState&gt; {
       fn write_slot(ref self: ContractState, value: u32) {
           storage_write_syscall(0, get_address_from_name(SLOT_NAME), value.into());
       }

       fn read_slot(self: @ContractState) -&gt; u32 {
           storage_read_syscall(0, get_address_from_name(SLOT_NAME))
               .unwrap_syscall()
               .try_into()
               .unwrap()
       }
   }
   fn get_address_from_name(variable_name: felt252) -&gt; StorageAddress {
       let mut data: Array&lt;felt252&gt; = ArrayTrait::new();
       data.append(variable_name);
       let hashed_name: felt252 = poseidon_hash_span(data.span());
       let MASK_250: u256 = 0x03ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
       // By taking the 250 least significant bits of the hash output, we get a valid 250bits storage address.
       let result: felt252 = (hashed_name.into() &amp; MASK_250).try_into().unwrap();
       let result: StorageAddress = result.try_into().unwrap();
       result
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x033943CB781A4E63C9dcE0A1A09eAa3b617AA43CC61637C08c043a67f3fe0087">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch02-advanced-concepts/write_to_any_slot/src/contract.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储数组"><a class="header" href="#存储数组">存储数组</a></h1>
<p>在 Starknet 上，复数值（例如元组或结构）存储在从存储变量的地址开始的连续段中。复杂存储值的最大大小有 256 个字段元素的限制，这意味着要在存储中存储超过 255 个元素的数组，我们需要将其分成不同大小的段并将这些段存储在多个存储地址中<code>n &lt;= 255</code>。目前开罗没有对存储数组的本机支持，因此您需要为<code>Store</code>要存储的数组类型编写自己的特征实现。</p>
<blockquote>
<p>注意：虽然可以将数组存储在存储器中，但并不总是建议这样做，因为读取和写入操作的成本可能会非常高。例如，读取大小的数组<code>n</code>需要<code>n</code>存储读取，写入大小的数组<code>n</code>需要<code>n</code>存储写入。如果一次只需要访问数组的单个元素，建议使用 a<code>LegacyMap</code>并将长度存储在另一个变量中。</p>
</blockquote>
<p>以下示例演示了如何编写<code>StorageAccess</code>该<code>Array&lt;felt252&gt;</code>类型的特征的简单实现，使我们能够存储最多包含 255 个<code>felt252</code>元素的数组。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl StoreFelt252Array of Store&lt;Array&lt;felt252&gt;&gt; {
   fn read(address_domain: u32, base: StorageBaseAddress) -&gt; SyscallResult&lt;Array&lt;felt252&gt;&gt; {
       StoreFelt252Array::read_at_offset(address_domain, base, 0)
   }

   fn write(
       address_domain: u32, base: StorageBaseAddress, value: Array&lt;felt252&gt;
   ) -&gt; SyscallResult&lt;()&gt; {
       StoreFelt252Array::write_at_offset(address_domain, base, 0, value)
   }

   fn read_at_offset(
       address_domain: u32, base: StorageBaseAddress, mut offset: u8
   ) -&gt; SyscallResult&lt;Array&lt;felt252&gt;&gt; {
       let mut arr: Array&lt;felt252&gt; = ArrayTrait::new();

       // Read the stored array's length. If the length is superior to 255, the read will fail.
       let len: u8 = Store::&lt;u8&gt;::read_at_offset(address_domain, base, offset)
           .expect('Storage Span too large');
       offset += 1;

       // Sequentially read all stored elements and append them to the array.
       let exit = len + offset;
       loop {
           if offset &gt;= exit {
               break;
           }

           let value = Store::&lt;felt252&gt;::read_at_offset(address_domain, base, offset).unwrap();
           arr.append(value);
           offset += Store::&lt;felt252&gt;::size();
       };

       // Return the array.
       Result::Ok(arr)
   }

   fn write_at_offset(
       address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut value: Array&lt;felt252&gt;
   ) -&gt; SyscallResult&lt;()&gt; {
       // // Store the length of the array in the first storage slot.
       let len: u8 = value.len().try_into().expect('Storage - Span too large');
       Store::&lt;u8&gt;::write_at_offset(address_domain, base, offset, len);
       offset += 1;

       // Store the array elements sequentially
       loop {
           match value.pop_front() {
               Option::Some(element) =&gt; {
                   Store::&lt;felt252&gt;::write_at_offset(address_domain, base, offset, element);
                   offset += Store::&lt;felt252&gt;::size();
               },
               Option::None(_) =&gt; { break Result::Ok(()); }
           };
       }
   }

   fn size() -&gt; u8 {
       255 * Store::&lt;felt252&gt;::size()
   }
}
<span class="boring">}</span></code></pre></pre>
<p>然后，您可以在合约中导入此实现，并使用它在存储中存储数组：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait IStoreArrayContract&lt;TContractState&gt; {
   fn store_array(ref self: TContractState, arr: Array&lt;felt252&gt;);
   fn read_array(self: @TContractState) -&gt; Array&lt;felt252&gt;;
}

#[starknet::contract]
mod StoreArrayContract {
   use super::StoreFelt252Array;

   #[storage]
   struct Storage {
       arr: Array&lt;felt252&gt;
   }

   #[abi(embed_v0)]
   impl StoreArrayImpl of super::IStoreArrayContract&lt;ContractState&gt; {
       fn store_array(ref self: ContractState, arr: Array&lt;felt252&gt;) {
           self.arr.write(arr);
       }

       fn read_array(self: @ContractState) -&gt; Array&lt;felt252&gt; {
           self.arr.read()
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://goerli.voyager.online/contract/0x008F8069a3Fcd7691Db46Dc3b6F9D2C0436f9200E861330957Fd780A3595da86">在Voyager</a>上访问合约或在<a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch02-advanced-concepts/storing_arrays/src/contract.cairo">Remix</a>中使用它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体作为映射键"><a class="header" href="#结构体作为映射键">结构体作为映射键</a></h1>
<p>为了使用结构作为映射键，您可以<code>#[derive(Hash)]</code>在结构定义上使用。这将自动为该结构生成一个哈希函数，该函数可用于将该结构表示为<code>LegacyMap</code>.</p>
<p>考虑以下示例，其中我们希望使用类型的对象<code>Pet</code>作为<code>LegacyMap</code>. 该<code>Pet</code>结构体具有三个字段：<code>name</code>、<code>age</code>和<code>owner</code>。我们认为这三个字段的组合可以唯一地标识宠物。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Drop, Serde, Hash)]
struct Pet {
   name: felt252,
   age: u8,
   owner: felt252,
}

#[starknet::interface]
trait IPetRegistry&lt;TContractState&gt; {
   fn register_pet(ref self: TContractState, key: Pet, timestamp: u64);
   fn get_registration_date(self: @TContractState, key: Pet) -&gt; u64;
}

#[starknet::contract]
mod PetRegistry {
   use hash::{HashStateTrait, Hash};
   use super::Pet;

   #[storage]
   struct Storage {
       registration_time: LegacyMap::&lt;Pet, u64&gt;,
   }

   #[abi(embed_v0)]
   impl PetRegistry of super::IPetRegistry&lt;ContractState&gt; {
       fn register_pet(ref self: ContractState, key: Pet, timestamp: u64) {
           self.registration_time.write(key, timestamp);
       }

       fn get_registration_date(self: @ContractState, key: Pet) -&gt; u64 {
           self.registration_time.read(key)
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch02-advanced-concepts/struct_as_mapping_key/src/contract.cairo">在Remix</a>中播放此合约。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优化"><a class="header" href="#优化">优化</a></h1>
<p>一系列节省气体和步骤的优化模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储优化"><a class="header" href="#存储优化">存储优化</a></h1>
<p><strong>智能合约的存储槽位</strong>数量是有限的。每个槽可以存储一个<code>felt252</code>值。写入存储槽是有成本的，因此我们希望使用尽可能少的存储槽。</p>
<p>在 Cairo 中，每种类型都派生自该<code>felt252</code>类型，该类型使用 252 位来存储值。这种设计非常简单，但它确实有一个缺点：存储效率不高。例如，如果我们想要存储一个<code>u8</code>值，我们需要使用整个槽，即使我们只需要 8 位。</p>
<h2 id="包装"><a class="header" href="#包装">包装</a></h2>
<p>当存储多个值时，我们可以使用一种称为<strong>打包</strong>的技术。打包是一种允许我们将多个值存储在单个毛毡值中的技术。这是通过使用毡值的位来存储多个值来完成的。</p>
<p>例如，如果我们要存储两个<code>u8</code>值，我们可以使用毛毡值的前 8 位存储第一个u8值，后 8 位存储第二个<code>u8</code>值。这样，我们可以将两个u8值存储在一个感觉值中。</p>
<p>Cairo 提供了一个使用包装的内置商店，您可以将其与该<code>StorePacking</code>特征一起使用。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait StorePacking&lt;T, PackedT&gt; {
   fn pack(value: T) -&gt; PackedT;
   fn unpack(value: PackedT) -&gt; T;
}
<span class="boring">}</span></code></pre></pre>
<p>这允许这允许<code>T</code>通过首先使用函数将其打包到类型中来<code>PackedT</code>存储类型<code>pack</code>，然后将<code>PackedT</code>值与其<code>Store</code>实现一起存储。读取值时，我们首先检索该<code>PackedT</code>值，然后<code>T</code>使用<code>unpack</code>函数将其解压到类型中。</p>
<p>这是使用特征存储<code>Time</code>具有两个值的结构的示例：<code>u8</code> <code>StorePacking</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[starknet::interface]
trait ITime&lt;TContractState&gt; {
   fn set(ref self: TContractState, value: TimeContract::Time);
   fn get(self: @TContractState) -&gt; TimeContract::Time;
}

#[starknet::contract]
mod TimeContract {
   use starknet::storage_access::StorePacking;
   use integer::{
       U8IntoFelt252, Felt252TryIntoU16, U16DivRem, u16_as_non_zero, U16IntoFelt252,
       Felt252TryIntoU8
   };
   use traits::{Into, TryInto, DivRem};
   use option::OptionTrait;
   use serde::Serde;

   #[storage]
   struct Storage {
       time: Time
   }

   #[derive(Copy, Serde, Drop)]
   struct Time {
       hour: u8,
       minute: u8
   }

   impl TimePackable of StorePacking&lt;Time, felt252&gt; {
       fn pack(value: Time) -&gt; felt252 {
           let msb: felt252 = 256 * value.hour.into();
           let lsb: felt252 = value.minute.into();
           return msb + lsb;
       }
       fn unpack(value: felt252) -&gt; Time {
           let value: u16 = value.try_into().unwrap();
           let (q, r) = U16DivRem::div_rem(value, u16_as_non_zero(256));
           let hour: u8 = Into::&lt;u16, felt252&gt;::into(q).try_into().unwrap();
           let minute: u8 = Into::&lt;u16, felt252&gt;::into(r).try_into().unwrap();
           return Time { hour, minute };
       }
   }

   #[abi(embed_v0)]
   impl TimeContract of super::ITime&lt;ContractState&gt; {
       fn set(ref self: ContractState, value: Time) {
           // This will call the pack method of the TimePackable trait
           // and store the resulting felt252
           self.time.write(value);
       }
       fn get(self: @ContractState) -&gt; Time {
           // This will read the felt252 value from storage
           // and return the result of the unpack method of the TimePackable trait
           return self.time.read();
       }
   }
}
<span class="boring">}</span></code></pre></pre>
<p><a href="https://remix.ethereum.org/?#activate=Starknet-cairo1-compiler&amp;url=https://github.com/NethermindEth/StarknetByExample/blob/main/listings/ch02-advanced-concepts/store_using_packing/src/contract.cairo">在Remix</a>中播放此合约。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
